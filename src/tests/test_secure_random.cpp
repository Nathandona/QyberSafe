#include <gtest/gtest.h>
#include <vector>
#include <memory>
#include <chrono>
#include "qybersafe/core/secure_random.h"

class SecureRandomTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Reset the singleton before each test
        // Note: This assumes we have a way to reset for testing
    }

    void TearDown() override {
        // Clean up after each test
    }
};

// Test singleton pattern
TEST_F(SecureRandomTest, SingletonAccess) {
    auto& instance1 = qybersafe::core::SecureRandom::instance();
    auto& instance2 = qybersafe::core::SecureRandom::instance();

    EXPECT_EQ(&instance1, &instance2);
    EXPECT_TRUE(instance1.is_initialized());
}

// Test byte generation
TEST_F(SecureRandomTest, GenerateBytes) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    // Test various sizes
    for (size_t size : {0, 1, 16, 32, 64, 256, 1024}) {
        auto result = rng.generate_bytes(size);
        ASSERT_TRUE(result.is_success()) << "Failed to generate " << size << " bytes: " << result.error();

        const auto& bytes = result.value();
        EXPECT_EQ(bytes.size(), size);

        // For non-zero size, ensure not all bytes are the same (basic randomness check)
        if (size > 1) {
            bool has_variation = false;
            for (size_t i = 1; i < size; ++i) {
                if (bytes[i] != bytes[0]) {
                    has_variation = true;
                    break;
                }
            }
            EXPECT_TRUE(has_variation) << "All generated bytes are identical for size " << size;
        }
    }
}

// Test integer generation
TEST_F(SecureRandomTest, GenerateUint8) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    auto result = rng.generate_uint8();
    ASSERT_TRUE(result.is_success()) << "Failed to generate uint8: " << result.error();

    // Test multiple generations to ensure variety
    std::vector<uint8_t> values;
    for (int i = 0; i < 100; ++i) {
        auto val_result = rng.generate_uint8();
        ASSERT_TRUE(val_result.is_success());
        values.push_back(val_result.value());
    }

    // Basic statistical check - should have both 0s and 1s in bit positions
    bool has_zero_in_lsb = false, has_one_in_lsb = false;
    for (uint8_t val : values) {
        if (val & 0x01) has_one_in_lsb = true;
        else has_zero_in_lsb = true;

        if (has_zero_in_lsb && has_one_in_lsb) break;
    }

    EXPECT_TRUE(has_zero_in_lsb) << "Never generated a value with LSB = 0";
    EXPECT_TRUE(has_one_in_lsb) << "Never generated a value with LSB = 1";
}

TEST_F(SecureRandomTest, GenerateUint16) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    auto result = rng.generate_uint16();
    ASSERT_TRUE(result.is_success()) << "Failed to generate uint16: " << result.error();

    // Should be within valid range
    EXPECT_GE(result.value(), 0);
    EXPECT_LE(result.value(), UINT16_MAX);
}

TEST_F(SecureRandomTest, GenerateUint32) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    auto result = rng.generate_uint32();
    ASSERT_TRUE(result.is_success()) << "Failed to generate uint32: " << result.error();

    // Should be within valid range
    EXPECT_GE(result.value(), 0);
    EXPECT_LE(result.value(), UINT32_MAX);
}

TEST_F(SecureRandomTest, GenerateUint64) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    auto result = rng.generate_uint64();
    ASSERT_TRUE(result.is_success()) << "Failed to generate uint64: " << result.error();

    // Should be within valid range
    EXPECT_GE(result.value(), 0);
    EXPECT_LE(result.value(), UINT64_MAX);
}

// Test range generation
TEST_F(SecureRandomTest, GenerateRange) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    // Test various ranges
    std::vector<std::pair<uint32_t, uint32_t>> ranges = {
        {0, 10},
        {5, 15},
        {0, UINT32_MAX},
        {100, 200},
        {UINT32_MAX - 10, UINT32_MAX}
    };

    for (const auto& range : ranges) {
        uint32_t min_val = range.first;
        uint32_t max_val = range.second;

        // Generate multiple values and test they're within range
        for (int i = 0; i < 100; ++i) {
            auto result = rng.generate_range(min_val, max_val);
            ASSERT_TRUE(result.is_success()) << "Failed to generate in range ["
                                             << min_val << ", " << max_val << "]: " << result.error();

            uint32_t value = result.value();
            EXPECT_GE(value, min_val) << "Generated value " << value
                                      << " below minimum " << min_val;
            EXPECT_LT(value, max_val) << "Generated value " << value
                                     << " above maximum " << max_val;
        }
    }
}

// Test invalid ranges
TEST_F(SecureRandomTest, GenerateRangeInvalid) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    // Test invalid ranges
    auto result1 = rng.generate_range(10, 5);  // min >= max
    EXPECT_FALSE(result1.is_success());
    EXPECT_TRUE(result1.error().find("Invalid range") != std::string::npos);

    auto result2 = rng.generate_range(5, 5);  // min == max
    EXPECT_FALSE(result2.is_success());
}

// Test boolean generation
TEST_F(SecureRandomTest, GenerateBool) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    int true_count = 0;
    int false_count = 0;
    const int iterations = 1000;

    for (int i = 0; i < iterations; ++i) {
        auto result = rng.generate_bool();
        ASSERT_TRUE(result.is_success()) << "Failed to generate boolean: " << result.error();

        if (result.value()) {
            ++true_count;
        } else {
            ++false_count;
        }
    }

    // Basic statistical check - should have both true and false values
    EXPECT_GT(true_count, 0) << "Never generated true";
    EXPECT_GT(false_count, 0) << "Never generated false";

    // Should be roughly balanced (within reasonable statistical bounds)
    double true_ratio = static_cast<double>(true_count) / iterations;
    EXPECT_TRUE(true_ratio > 0.3 && true_ratio < 0.7)
        << "Boolean generation appears biased: true ratio = " << true_ratio;
}

// Test buffer filling
TEST_F(SecureRandomTest, FillBytes) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    std::vector<size_t> sizes = {1, 16, 64, 256};

    for (size_t size : sizes) {
        std::vector<uint8_t> buffer(size);

        auto result = rng.fill_bytes(buffer.data(), size);
        ASSERT_TRUE(result.is_success()) << "Failed to fill buffer of size " << size
                                        << ": " << result.error();

        // Check that buffer was modified (basic randomness check)
        bool has_variation = false;
        for (size_t i = 1; i < size; ++i) {
            if (buffer[i] != buffer[0]) {
                has_variation = true;
                break;
            }
        }

        if (size > 1) {
            EXPECT_TRUE(has_variation) << "Buffer appears unchanged for size " << size;
        }
    }
}

// Test null buffer handling
TEST_F(SecureRandomTest, FillBytesNullBuffer) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    auto result = rng.fill_bytes(nullptr, 10);
    EXPECT_FALSE(result.is_success());
    EXPECT_TRUE(result.error().find("Buffer is null") != std::string::npos);
}

// Test reinitialization
TEST_F(SecureRandomTest, Reinitialize) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    // Generate some data to verify initialization
    auto result1 = rng.generate_bytes(16);
    ASSERT_TRUE(result1.is_success());

    // Reinitialize
    auto reinit_result = rng.reinitialize();
    ASSERT_TRUE(reinit_result.is_success());

    // Should still be able to generate data
    auto result2 = rng.generate_bytes(16);
    ASSERT_TRUE(result2.is_success());

    // Should be different (very high probability)
    const auto& data1 = result1.value();
    const auto& data2 = result2.value();
    bool different = false;
    for (size_t i = 0; i < 16; ++i) {
        if (data1[i] != data2[i]) {
            different = true;
            break;
        }
    }
    EXPECT_TRUE(different) << "Reinitialized generator produced same data";
}

// Test global convenience functions
TEST_F(SecureRandomTest, GlobalFunctions) {
    // Test random_bytes
    auto bytes_result = qybersafe::core::random_bytes(32);
    ASSERT_TRUE(bytes_result.is_success());
    EXPECT_EQ(bytes_result.value().size(), 32);

    // Test random_uint32
    auto uint32_result = qybersafe::core::random_uint32();
    ASSERT_TRUE(uint32_result.is_success());
    EXPECT_GE(uint32_result.value(), 0);
    EXPECT_LE(uint32_result.value(), UINT32_MAX);

    // Test random_uint64
    auto uint64_result = qybersafe::core::random_uint64();
    ASSERT_TRUE(uint64_result.is_success());
    EXPECT_GE(uint64_result.value(), 0);
    EXPECT_LE(uint64_result.value(), UINT64_MAX);

    // Test random_range
    auto range_result = qybersafe::core::random_range(10, 20);
    ASSERT_TRUE(range_result.is_success());
    EXPECT_GE(range_result.value(), 10);
    EXPECT_LT(range_result.value(), 20);

    // Test random_bool
    auto bool_result = qybersafe::core::random_bool();
    ASSERT_TRUE(bool_result.is_success());

    // Test fill_random
    std::vector<uint8_t> buffer(16);
    auto fill_result = qybersafe::core::fill_random(buffer.data(), 16);
    ASSERT_TRUE(fill_result.is_success());
}

// Performance test (not a benchmark, just ensures reasonable performance)
TEST_F(SecureRandomTest, PerformanceTest) {
    auto& rng = qybersafe::core::SecureRandom::instance();

    const size_t iterations = 1000;
    const size_t bytes_per_iteration = 1024;

    auto start = std::chrono::high_resolution_clock::now();

    for (size_t i = 0; i < iterations; ++i) {
        auto result = rng.generate_bytes(bytes_per_iteration);
        ASSERT_TRUE(result.is_success());
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    // Should complete within reasonable time (5 seconds for 1MB of random data)
    EXPECT_LT(duration.count(), 5000) << "Random generation too slow: " << duration.count() << "ms";
}